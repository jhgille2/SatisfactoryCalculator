---
title: "Designing Satisfactory factories with linear programming"
author: "Jay Gillenwater"
date: "2022-08-12"
output: html_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(DiagrammeR)
```

## Introduction

Satisfactory is a game where you process raw resources into increasingly complicated refined items. As the game progresses, the manner in which these raw resources are processed and combined becomes more complicated and introduces some problems that are difficult to tackle by hand or with mental math alone (at least for me). This is especially true in the case that often arises where a resource is required for several items at the same time that are all necessary to procude in order to advance in the game. Linear programming offers a easy solution to many of these problems and has been effectively used by many popular calculators for the game which help with factory design. 

In this document, I want to describe the specific problems I am trying to solve with this repository and keep track of how I have attempted to solve them. 

## The basic problem

Raw resoruces in satisfactory come from a finite number of raw resource **nodes**. Each of these nodes produce an infinite amount of some raw resource at a set rate that depends on the building that is placed on the node, and any upgrades that have been made to that building. 

Progress is made in the game by completing **milestones** which each require some amount of a product to be made. These products are made by transforming the raw resource into intermediary products, and combining or further transforming these intermediaries to produce the final product. The way in which these final products is produced from the raw resources is called a **recipe**. For an example, consider the early game recipes for iron plates and iron rods:
  
```{r, Iron_Diagram, echo = FALSE}
grViz("
digraph a_nice_graph {

# node definitions with substituted label text
node [fontname = Helvetica]
a [label = '@@1']
b [label = '@@2']
c [label = '@@3']
d [label = '@@4']


# edge definitions with the node IDs
a -> b [color = Red]
b -> c [color = Blue]
b -> d [color = Blue]
}

[1]: 'Iron ore'
[2]: 'Iron ingot'
[3]: 'Iron rod'
[4]: 'Iron plate'

")
  
```
I used colors to indicate what building makes each product. In the diagram above, a red arrow indicates a process is done in a smelter, and a blue arrow indicates a constructor is used. 

In satisfactory, the limiting factor for production is not the resources themselves as they can be infinitely mines, but rather the rate at which a particular raw resource is being extracted, and subsequently made available for consumption. As a simple example, consider a single normal iron ore node is available. With a tier 1 miner, this node will produce 60 iron ore per minute. The question now becomes what proportion of that rate should be committed to producing iron rods, and how much should go towards the plates?

Ultimately, there isn't an actual answer to this question. Both items are needed, so as long as you are making more than 0 of each product, you'll eventually meet the milestone. However, I think a good objective here first would be to produce an amount of plates and/or rods that consumes all the currently available iron ore rate without having to under clock any factories. To do this, you first have to know the rates at which items are consumed to produce products. In this case:

$30\ Iron\ ore = 30\ Iron\ ingot$  
$30\ Iron\ ingot = 20\ Iron\ plate$  
$15\ Iron\ ingot = 15\ Iron\ rod$  

Put in other words, for each iron ore/min, you can produce 1 ingot/min. You can also produce 1 iron rod/min for every ingot/min. However, you can only produce iron plates at 2/3 the rate that ingots are supplied. In this case, you really only have to worry about the rates that just the iron plate and iron rod recipes consume ingots since ore is converted to ingots at a 1:1 ratio. 

This example is pretty straightforward, if you don't want to under clock you can either maximize iron plates and build two factories (2x30 = 60), maximize iron rods and build four factories (4x15 = 60), or produce both and make 1 plate factory and two rod factories [(1x30) + (2x15) = 60].

This example is pretty trivial, but how about when things get a bit spicier? The first headache-inducing production tree I ran into was when I needed to make both reinforced iron plates and rotors at the same time.

```{r, rplate_rotor_Diagram, echo = FALSE}
grViz("
digraph a_nice_graph {

# node definitions with substituted label text
node [fontname = Helvetica]
a [label = '@@1']
b [label = '@@2']
c [label = '@@3']
d [label = '@@4']
e [label = '@@5']
f [label = '@@6']
g [label = '@@7']


# edge definitions with the node IDs
a -> b [color = Red]
b -> c [color = Blue]
b -> d [color = Blue]
d -> f [color = Green]
c -> e [color = Blue]
e -> f [color = Green]
c -> g [color = Green]
e -> g [color = Green]
}

[1]: 'Iron ore'
[2]: 'Iron ingot'
[3]: 'Iron rod'
[4]: 'Iron plate'
[5]: 'Screw'
[6]: 'Reinforced iron plate'
[7]: 'Rotor'

")
  
```
Headache inducing for a couple reasons. First, both reinforced iron plates and rotors need screws, and also the rotor recipe needs both screws and iron rods...but screws are made from iron rods too.....so you have to balance screws with iron rods to make rotors....but also you need to make screws to make reinforced plates...oh boy.

It was here that I turned to the hard work that had already been done by people trying to [solve similar problems in factorio](https://kirkmcdonald.github.io/posts/calculation.html) for a better way of representing the recipe data that would actually let me make decisions with math of all things. Instead of a graph or table, the recipes can be represented with a matrix that has individual recipes that you'd input into the buildings in the columns and the items that the recipes require/produce in the columns. 